# 基于内容的简单图像检索系统

## 添加功能和优化
* 代码重构 2.0 (✔)
  * 类封装 (✔)
  * Gui 重写 (✔)
  * 输出结果排序 (✔)
  * 根据输出结果数量，显示图片 (✔)
  * 计时检索速度 (✔)
  * 前 n 张输出结果的平均 loss (✔)

* 处理异常 (✔)
  * 添加判断条件，弹出提示 (✔)
  * 添加 try-except，弹出提示 (✔)

* 调整参数 (loss 阈值) (✔)

* 检索时，显示加载中提示

* 预处理图像 (多线程) (✔)
  * 处理进度 (✔)

## 运行程序
* 配置环境
  ```bash
  pip install -r packages.txt
  ```

* 运行
  ```bash
  python GUI_PyQt.py
  ```

## 系统工作流程
1. 特征提取：Pretreat，对数据库里的图像进行特征提取  
  在建立图像数据库时，系统对输入的图像进行分析，提取图像特征存入特征库，同时对特征库建立索引以提高查找效率

2. 相似度匹配：检索，对输入图像进行特征特征提取后计算相似度  
  采用相似性匹配算法计算关键图像特征与特征库中图像特征的相似度，然后按照相似度从大到小的顺序将匹配图像进行反馈

1. 整体系统架构思想 & 代码逻辑  
   * `Pretreatment/` 预处理数据库内图像的 py 脚本
   * `Repository/` 存放图像特征数据库
   * `Service/` 存放对输入图像进行处理的 py 脚本
   * 将预处理和处理输入图像的 py 脚本里的函数封装为类
   * 执行预处理。将预处理 py 脚本放入多线程中、在后台进行执行；通过 Qt 信号槽机制，当开始或完成时发出信号，主界面显示进度提示。
   * 输入图像处理并得到结果。同样利用信号槽机制，点击相应按钮，首先获取图片并弹出提示框输入 loss_threshold，成功后生成 `ShowPicWidget.py` 的类的对象（根据前一步函数接收的参数，通过字典 `(int, string)` 来对应该生成哪个对象），这个是结果显示窗口，在显示前先执行对应的检索方法（根据类接收的参数），获得其返回结果。
   * 数据库中存储了每个库中图像的特征和访问路径，当匹配到时，append loss 值和访问路径到新数组中。`ShowPicWidget` 对象读取访问路径、显示结果。
   * 默认设定返回 20 个最佳结果。第一个最佳，之后 loss 从小到大排序。界面显示处理用时长。界面显示前 n 个平均 loss (n <= 20)。
   * 有错误提示，如文件未读取到、阈值输入不规范、未能加载预处理文件等。


## 特征提取
图像的特征包括基于文本的特征（关键字、注释）和视觉特征（颜色、纹理、形状）两类。本次实践是后者。  
* 颜色  
  对噪声，图像质量的退化，尺寸、分辨率和方向等的变化具有很强的鲁棒性，是绝大多数基于内容的图像和视频检索的多媒体数据库中使用的特征之一。  
  
  实践中使用 HSV 中心距法。

* 纹理  
  定义为图像的某种局部性质，或是对局部区域中像素之间关系的一种度量，其本质是刻画像素的邻域灰度空间分布规律。纹理特征描述方法大致可以分为四类：统计法、结构法、模型法、频谱法。  

  实践中使用 灰度矩阵法。

* 形状  
  刻画物体最本质的特征，也是最难描述的图像特征之一，主要难在对图像中感兴趣目标的分割。对形状特征的提取主要是寻找一些几何不变量。用于图像检索的形状描述方法主要有两类:基于边缘和基于区域的形状方法。前者利用图像的边缘信息，而后者则利用区域内的灰度分布信息。  

  实践中使用 不变矩法 和 边缘直方图法。

## 特征匹配
从图像中提取的特征可以组成一个向量，两个图像之间可以通过定义一个距离或者相似性的测量度来计算相似程度。


## 算法
### 基于颜色的 HSV 中心距法
#### 颜色矩
[理解“矩”的概念](https://blog.csdn.net/ccnt_2012/article/details/109766892)  
[颜色矩、颜色直方图](https://blog.csdn.net/LLLLnannan/article/details/118337636)

就是相当于计算期望。数学基础在于图像中任何的颜色分布均可以用它的矩来表示。此外，由于颜色分布信息主要集中在低阶矩中，因此仅采用颜色的一阶矩（mean）、二阶矩（variance）和三阶矩（skewness）就足以表达图像的颜色分布。与颜色直方图相比，该方法的另一个好处在于无需对特征进行向量化。

* 原点矩、中心矩  
  * 原点矩就是与原点，也就是与X轴上 0 点的距离
  * 中心指的是变量的均值，中心矩就是与 X 轴上均值处的距离

    ![](https://img2020.cnblogs.com/blog/1617754/202007/1617754-20200706172517813-235122652.png)
    > i 是图像的颜色通道数，若为灰度图像，i = 1；若为彩色图像，i = 3。Pij 为第 j 个像素在第 i 个颜色通道上的颜色值

* 一阶颜色矩（均值）  
  * 反映图像明暗程度。值越大，图像越亮。
  * 概率 p 是 1/N

* 二阶颜色矩（标准差）
  * 反映图像的颜色分布范围，值越大，颜色分布范围越广。

* 三阶颜色矩（偏度）
  * 反映图像颜色分布的对称性。
  * 当 Si=0 时，图像的颜色分布是对称的；  
    当 Si<0 时，颜色分布左偏或负偏（左侧尾部长，大头在右边）；  
    当 Si>0 时，颜色分布右偏或正偏（右侧尾部长，大头在左边）。  
    
    ![](https://img-blog.csdnimg.cn/20181123105910265.png)

#### HSV 空间
[RGB、HSV 空间](https://zhuanlan.zhihu.com/p/67930839)
* H  
  色彩，红：0°，绿：120°，蓝：240°，每种颜色对应某一个角度。
* S  
  饱和度，饱和度越高，说明颜色越深，越接近光谱色；饱和度越低，说明颜色越浅，越接近白色。
* V  
  明度，明度越高，表示颜色越明亮，范围是 0-100%。明度为0表示纯黑色。
* 图像识别都会运用 HSV 颜色空间，HSV 颜色空间表达更加直观。

#### 代码流程
1. 预处理  
   
   cv2 库，`cv2.cvtcolor()`，`BGR2HSV`。建立特征数据库，输出 N * 9 的矩阵，9 = 3（一、二、三阶矩） * 3（H、S、V）。

2. 匹配  
   
   1 * 9 向量中，9 个维度每个进行差值计算后（范围 0~1，看作归一化）求和，得到这个向量（图片）与数据库中某个图片的 loss 值，限定 loss 阈值，最后按照 loss 从大到小输出。  

   $\sum_9^i$(input[i] - data[i]) / input[i]


### 基于纹理的灰度矩阵法
[灰度共生矩阵](https://blog.csdn.net/kmsj0x00/article/details/79463376)  
[灰度共生矩阵（简单理解）](https://blog.csdn.net/qq_36654309/article/details/106473599)  
[灰度共生矩阵](https://zhuanlan.zhihu.com/p/295444415)
#### 求解原理
* 统计了灰度图中像素间的灰度值分布规律以区分不同的纹理。
* 维度较大，不直接作为区分纹理的特征。基于它构建的一些统计量作为纹理分类特征。
* 基于灰度共生矩阵计算出来的统计量：能量、熵、对比度、均匀性、相关性、方差、和平均、和方差、和熵、差方差、差平均、差熵、相关信息测度以及最大相关系数。   

#### 基本计算方法
![](https://img-blog.csdn.net/20171020101818132?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzcwNTk0ODM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)  
> GLCM(1, 1) 值为 1 说明只有一对灰度值为 (1, 1) 的像素水平相邻。GLCM(1, 2) 值为 2，有两对灰度为 (1, 2) 的像素水平相邻

GLCM(1, 1) 就是 I 中像素值为 (1, 1) 的组合，GLCM(4, 5) 就是 I 中像素 4 和像素 5 的组合，GLCM(i, j) 的值就是 I 中像素为 (i, j) 的相邻成对点。相邻规则：f(x, y), f(x+a, y+b) 相邻，x 相隔 a 的单位，y 相隔 b 个单位，我们认为是相邻的。 
平时我们说相邻：B点在A点右边，其实就是这里的 a=1, b=0，也就是 f(x, y) 和 f(x+1, y+0) 相邻。  
a=1, b=0 时我们就说水平相邻：也就是 0 度 
a=1, b=1 时我们就说对角相邻，也就是 45 度  
a=-1, b=1 时即 135 度 

#### 矩阵求解
* 纹理是由灰度在空间位置上反复出现而形成的，因而在图像空间中相隔某距离的两像素之间会存在一定的灰度关系，即图像中灰度的空间相关特性。灰度共生矩阵就是一种通过研究灰度的空间相关特性来描述纹理的常用方法。
* 取图像 (N×N) 中任意一点 (x, y) 及偏离它的另一点 (x+a, y+b)，设该点对的灰度值为 (g1, g2)。令点 (x, y) 在整个画面上移动，则会得到各种 (g1, g2) 值，设灰度值的级数为 k，则 (g1, g2) 的组合共有 k^2 种。对于整个画面，统计出每一种 (g1, g2) 值出现的次数，然后排列成一个方阵，在用 (g1, g2) 出现的总次数将它们归一化为出现的概率P(g1, g2)，这样的方阵称为灰度共生矩阵。距离差分值 (a, b) 取不同的数值组合，可以得到不同情况下的联合概率矩阵。
* 选择的尺度不同，灰度共生矩阵也是不同的，为达到最佳的效果，需要通过实验验证，为了减少角度的影响，我们一般取四个角度 (0°, 45°, 90°, 135°), 然后取平均值。

#### 角二阶矩 ASM

![](https://img-blog.csdn.net/20161111141906402?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

角二阶矩又称能量，是图像灰度分布均匀程度和纹理粗细的一个度量。当图像纹理均一规则时，能量值较大；反之灰度共生矩阵的元素相近（当图像的像素随机性比较大，共生矩阵的元素就比较接近），能量值较小。当纹理比较规则时，共生矩阵的元素主要是集中对角线附近.其它元素主要为零。

#### 熵 ENT

![](https://img-blog.csdn.net/20161111142132005?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

图像包含信息量的随机性度量。当共生矩阵中所有值均相等或者像素值表现出最大的随机性时，熵最大；因此熵值表明了图像灰度分布的复杂程度，熵值越大，图像越复杂。

#### 对比度 CON

![](https://img-blog.csdn.net/20161111141524961?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

度量矩阵的值是如何分布和图像中局部变化的多少，反应了图像的清晰度和纹理的沟纹深浅。纹理的沟纹越深，反差越大，效果越清晰；反之，对比值小，则沟纹浅，效果模糊。  
有点类似于方差，但不是取平均，而是概率，权值不同。

#### 反差分矩阵 IDM

IDM = ∑<sub>i</sub>∑<sub>j</sub> ( P(i, j) / 1 + (i − j)<sup>2</sup> )

反差分矩阵又称逆方差，反映了纹理的清晰程度和规则程度，纹理清晰、规律性较强、易于描述的，值较大。

#### 代码流程
1. 计算灰度级数 gray_level  
   若灰度级数大于 gray_level，则将图像的灰度级缩小至 gray_level，减小灰度共生矩阵的大小。
2. 按照公式计算 灰度共生矩阵
3. 按照公式计算 特征量
4. 建立特征数据库，得到 N * 4 矩阵，4 分别为 4 个特征量的值
5. 匹配（与上文计算方法一致，然后限定 loss 阈值，小于阈值的图像加入到结果集中）


### 基于形状的形状边缘直方图法
[边缘直方图](https://blog.csdn.net/u013668078/article/details/48680849)  
[Canny 边缘检测直方图](https://zhuanlan.zhihu.com/p/95994377)
#### 算法思想
首先对图像进行分块，然后使用五种边缘描述子（MPEG-7将图像边缘分为五个方向，水平、竖直、斜45度、斜135度和无方向。这五种方向分别对应五个不同的边缘描述子）对各块的边缘方向信息进行提取，并画出直方图，在数据库中搜索与各小块中直方图匹配的数据。该方法运算速度快，适合大规模图像的查找，但是没能考虑图块的位置问题，不适用与精确的图像搜索。

#### 代码流程
感觉像是 Canny 边缘检测的四个步骤：高斯滤波、计算图像梯度、非极大值抑制、双阈值筛选  
1. 建立特征数据库，输出 N * 16 的矩阵。  
   16 的含义：  
   直方图显示了每个灰度值对应的像素数。如果像素值为 0 到 255，你就需要 256 个数来显示上面的直方图。但是，如果你不需要知道每一个像素值的像素点数目的，而只希望知道两个像素值之间的像素点数目。像素值在 0 到 15 之间的像素点的数目，接着是 16 到 31,....，240 到 255。我们只需要 16 个值来绘制直方图。  
   所以 16 中的每一份 cal[i] 表示的是长度为 16 的单位区间，统计这个区间内的像素数。

2. 匹配

### 基于形状的不变矩法
[Hu矩简介](https://blog.csdn.net/qq_37207090/article/details/83986950)
#### Hu不变矩
不变矩(Invariant Moments) 是一种高度浓缩的图像特征，具有平移、灰度、尺度、旋转不变性。Hu 矩是通过二阶和三阶中心矩可求得 7 个不变矩组。

![](https://img-blog.csdn.net/20170420135434957?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hhaXBwMDYwNw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)　　

Hu不变矩组成的特征量对图片进行识别，优点就是速度快，缺点是识别率比较低，对于纹理比较丰富的图片，识别率低。  

Hu不变矩一般用于识别图像中大的物体，对于物体的形状描述得比较好，图像的纹理特征不能太复杂，像识别水果形状，或者对于车牌中的简单字符的识别效果会相对好一些。

#### 代码流程
直接调用 `opencv` 库函数 `cv2.HuMoments(cv2.moments(img))`。返回七个不变矩的值。